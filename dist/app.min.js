/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var uniforms = {};
	uniforms.lfAmp = {};
	uniforms.hfAmp = {};
	var AudioController;

	__webpack_require__(1);

	window.onload = function () {
	        // Clubber testing
	        var clubber = new Clubber({
	                size: 2048, // Samples for the fourier transform. The produced linear frequency bins will be 1/2 that.
	                mute: false // whether the audio source should be connected to web audio context destination.
	        });

	        // Specify the audio source to analyse. Can be an audio/video element or an instance of AudioNode.
	        clubber.listen(document.getElementById('myAudio'));

	        if (!init()) animate();
	        /*
	        var AudioController = new AudioHandler();
	        AudioController.init();
	        update();
	          function update() {
	            requestAnimationFrame(update);
	            clubber.update(); // currentTime is optional and specified in ms.
	            console.log(clubber.notes);
	              AudioController.update();
	            uniforms.lfAmp.value = AudioController.lfAmplitude;
	            uniforms.hfAmp.value = AudioController.hfAmplitude;
	            AudioController.draw();
	        }
	        */
	        if (!init()) animate();
	        //AudioController.audio.play();
	};

	//*****************//
	// ****THREE JS ***//
	//*****************//

	var stats, scene, renderer, composer, light;
	var camera, cameraControls;
	var pyramidMesh, planetMaterial, particles, planetGeometry, bgMaterial;
	var stars = [];

	var time;
	var startTime = new Date().getTime();

	var PYRAMID_SCALE = 200;

	// init the scene
	window.addEventListener('resize', onWindowResize, false);

	function init() {

	        initScene();
	        postprocessing();
	        addLights();
	        addObjects();

	        time = 0;
	}
	function initScene() {

	        if (Detector.webgl) {
	                renderer = new THREE.WebGLRenderer({
	                        antialias: true, // to get smoother output
	                        preserveDrawingBuffer: true, // to allow screenshot
	                        alpha: true //To allow for background
	                });
	                renderer.setClearColor(0, 0, 0, 0);
	        } else {
	                renderer = new THREE.CanvasRenderer({ alpha: true });
	        }

	        renderer.setSize(window.innerWidth, window.innerHeight);
	        document.getElementById('container').appendChild(renderer.domElement);

	        // create a scene
	        scene = new THREE.Scene();

	        // put a camera in the scene
	        camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 10000);
	        camera.position.set(0, 0, 800);
	}

	function postprocessing() {
	        // Postprocessing
	        composer = new THREE.EffectComposer(renderer);
	        composer.addPass(new THREE.RenderPass(scene, camera));

	        // Film effect
	        var noiseIntensity = 1.0;
	        var scanlinesIntensity = 0.7;
	        var scanlinesCount = 4;
	        var grayscale = false;

	        var effectFilmLF = new THREE.FilmPass(noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale);
	        var effectFilmHF = new THREE.FilmPass(0.9, scanlinesIntensity, 1024, grayscale);

	        // RGB shift
	        var colorShiftEffect = new THREE.ShaderPass(THREE.RGBShiftShader);
	        colorShiftEffect.uniforms['amount'].value = 0.0015;
	        colorShiftEffect.renderToScreen = true;

	        // Add effects
	        //omposer.addPass(effectFilmLF);
	        composer.addPass(effectFilmHF);
	        composer.addPass(colorShiftEffect);

	        // create a camera contol
	        cameraControls = new THREE.TrackballControls(camera);

	        // transparently support window resize
	        THREEx.WindowResize.bind(renderer, camera);
	}

	function addLights() {

	        light = new THREE.DirectionalLight(0xffffff);
	        light.position.set(1000, 100, 100);
	        //light.position.set(0, 100, 600);
	        scene.add(light);
	}

	function addObjects() {

	        // Ground
	        var GROUND_DIM = 4000;
	        var GROUND_SQUARES = 100;

	        var groundGeometry = new THREE.PlaneGeometry(GROUND_DIM, GROUND_DIM, GROUND_SQUARES, GROUND_SQUARES);

	        uniforms.lightPos = { type: 'v3', value: light.position };
	        uniforms.time = { type: 'v3', value: 1.0 };
	        uniforms.lfAmp = { type: 'f', value: 0.0 };
	        uniforms.hfAmp = { type: 'f', value: 0.0 };

	        // Create two uniform arrays to get different colors on two materials, ugly but works
	        var WFUniforms = {};
	        var NoWFUniforms = {};

	        WFUniforms = Object.assign({}, uniforms, {
	                color1: { type: 'v3', value: [0.3, 0.4, 1.0] },
	                color2: { type: 'v3', value: [1.0, 0.0, 1.0] }
	        });

	        NoWFUniforms = Object.assign({}, uniforms, {
	                color1: { type: 'v3', value: [0.08, 0.13, 0.17] },
	                color2: { type: 'v3', value: [0.08, 0.13, 0.17] }
	        });

	        var groundMaterialWF = new THREE.ShaderMaterial({
	                uniforms: WFUniforms,
	                vertexShader: document.getElementById('vertexShader').textContent,
	                fragmentShader: document.getElementById('fragmentShader').textContent,
	                wireframe: true

	        });
	        var groundMaterial = new THREE.ShaderMaterial({
	                uniforms: NoWFUniforms,
	                vertexShader: document.getElementById('vertexShader').textContent,
	                fragmentShader: document.getElementById('fragmentShader').textContent
	        });

	        groundMaterialWF.extensions.derivatives = true;
	        groundMaterial.extensions.derivatives = true;

	        // TEMP
	        var planeMesh = THREE.SceneUtils.createMultiMaterialObject(groundGeometry, [groundMaterialWF, groundMaterial]);

	        planeMesh.position.y = -60; //-1.9
	        planeMesh.rotation.x = -Math.PI / 2;

	        scene.add(planeMesh);

	        // Background pyramid
	        var pyramidGeometry = new THREE.Geometry();

	        pyramidGeometry.vertices = [new THREE.Vector3(1, 0, -1), new THREE.Vector3(-1, 0, -1), new THREE.Vector3(-1, 0, 1), new THREE.Vector3(1, 0, 1), new THREE.Vector3(0, 2, 0)];
	        pyramidGeometry.faces = [new THREE.Face3(1, 0, 4), new THREE.Face3(2, 1, 4), new THREE.Face3(3, 2, 4), new THREE.Face3(0, 3, 4)];

	        // Pyramid
	        var geo = new THREE.EdgesGeometry(pyramidGeometry);
	        var mat = new THREE.LineBasicMaterial({ color: 0xFF00FF, linewidth: 2 });
	        pyramidMesh = new THREE.LineSegments(geo, mat);

	        scene.add(pyramidMesh);

	        pyramidMesh.scale.set(PYRAMID_SCALE, PYRAMID_SCALE, PYRAMID_SCALE);
	        pyramidMesh.position.set(0, -60, -1 * GROUND_DIM / 2);
	        pyramidMesh.position.z -= Math.sqrt(2 * Math.pow(PYRAMID_SCALE, 2));

	        //Background stars
	        var sprite = new THREE.TextureLoader().load("images/ball.png");
	        planetGeometry = new THREE.Geometry();
	        for (var i = 0; i < 300; i++) {
	                var planetVertex = new THREE.Vector3();
	                planetVertex.x = (-1 + 2 * Math.random()) * 1.4 * window.innerWidth;
	                planetVertex.y = (-1 + 2 * Math.random()) * 1.4 * window.innerWidth;
	                planetVertex.z = -1 * GROUND_DIM / 2 - 600;
	                planetGeometry.vertices.push(planetVertex);
	        }
	        planetMaterial = new THREE.PointsMaterial({ size: 30, sizeAttenuation: false, map: sprite, alphaTest: 0.5, transparent: true });
	        planetMaterial.color.setHSL(1.0, 0.3, 0.7);
	        particles = new THREE.Points(planetGeometry, planetMaterial);

	        scene.add(particles);

	        //BG
	        var bgGeometry = new THREE.PlaneGeometry(2 * GROUND_DIM, 2 * GROUND_DIM, GROUND_SQUARES, GROUND_SQUARES);
	        bgMaterial = new THREE.MeshBasicMaterial({
	                color: 0x123e84
	        });
	        var bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
	        bgMesh.position.z = -1 * GROUND_DIM / 2 - 800;
	        scene.add(bgMesh);

	        //Text
	        /** TODO **/
	}

	function updateObjects() {

	        // Pyramid
	        pyramidMesh.rotation.y += 0.0002 * Math.pow(uniforms.lfAmp.value, 1.2);
	        pyramidMesh.scale.y = PYRAMID_SCALE + 0.6 * uniforms.lfAmp.value;

	        // Planets
	        var h = 360 * (1.0 + time) % 360 / 360;
	        planetMaterial.color.setHSL(h, 0.5, 0.5);
	        planetMaterial.size = 5.0 + 0.6 * uniforms.lfAmp.value;
	        particles.rotation.z += 0.0001 * Math.pow(uniforms.lfAmp.value, 1.2);
	        particles.scale.y = 1 + 0.005 * uniforms.lfAmp.value;
	        particles.scale.x = 1 + 0.005 * uniforms.lfAmp.value;

	        // Background
	        bgMaterial.color.r = 0.01 + 0.5 * uniforms.lfAmp.value / 255;
	        bgMaterial.color.g = 0.04 + 0.2 * uniforms.lfAmp.value / 255;
	        bgMaterial.color.b = 0.08 + 0.2 * uniforms.lfAmp.value / 255;

	        // Camera
	        camera.position.y = 0.6 * uniforms.lfAmp.value;
	        camera.position.x = 20 * Math.sin(time + 0.05 * uniforms.lfAmp.value);
	}

	// animation loop

	function onWindowResize() {
	        camera.aspect = window.innerWidth / window.innerHeight;
	        camera.updateProjectionMatrix();
	        renderer.setSize(window.innerWidth, window.innerHeight);
	}

	function animate() {
	        requestAnimationFrame(animate);
	        updateObjects();
	        render();
	}

	// render the scene
	function render() {
	        // variable which is increase by Math.PI every seconds - usefull for animation
	        time = (new Date().getTime() - startTime) / 1000;

	        // update camera controls
	        cameraControls.update();

	        // Update uniforms
	        uniforms.time.value = time;

	        // actually render the scene
	        composer.render(); //render with post processing
	        //renderer.render( scene, camera ); // render without post process
	}

/***/ },
/* 1 */
/***/ function(module, exports) {

	/* 
	* clubber.js 1.4.0 Copyright (c) 2016-2017, Yannis Gravezas All Rights Reserved.
	* Available via the MIT license. Go to http://github.com/wizgrav/clubber for more.
	*/

	var Clubber = function (config) {
	  if (!config) config = {};
	  this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
	  
	  var analyser = this.audioCtx.createAnalyser();
	  analyser.fftSize = config.size || 2048;
	  
	  Object.defineProperty(this, 'smoothing', {
	    get: function() {
	      return analyser.smoothingTimeConstant;
	    },
	    set: function(value) {
	      analyser.smoothingTimeConstant = value;
	    }
	  });
	  
	  this.analyser = analyser;
	  
	  this.bufferLength = this.analyser.frequencyBinCount;
	  
	  if (!config.mute) this.analyser.connect(this.audioCtx.destination);
	  
	  this.data = new Uint8Array(this.bufferLength);
	  this.keys = new Uint8Array(this.bufferLength);
	  this.noteSums = new Uint16Array(160);
	  this.notes = new Uint8Array(160);
	  this.weights = new Uint8Array(160);
	  
	  function freq2midi (freq){
	    var r=1.05946309436, lala=523.251, notetest=eval(freq), ref=lala, hauteur=1, octave=4, alteration, supinf=0, compteur=0, hautnb=1, noteton, ref1=0, ref2=0, temp, flag=0, nmidi=72;
	    tableau=new Array();
	    while (notetest<ref){
	        ref=Math.floor(1000*ref/r)/1000;
	        compteur=compteur+1;
	        supinf=-1;
	        flag=1;
	        ref1=ref;
	    }	
	    while (notetest>ref){
	        ref=Math.floor(1000*ref*r)/1000;
	        compteur=compteur-1;
	        supinf=1;
	        ref2=ref;
	    }
	    if (Math.abs(notetest-ref1)<Math.abs(notetest-ref2)) {
	      supinf=-1;
	      compteur=compteur+1;
	    } else {
	      if (flag==1){ supinf=-1;}
	    }
	    if (ref1==0) {
	      ref1=Math.floor(1000*ref/r)/1000;
	      if (Math.abs(notetest-ref1)<Math.abs(notetest-ref2)) {
	        compteur=compteur+1;
	        supinf=1;
	      }
	    }
	    compteur=Math.abs(compteur);
	    while (compteur != 0 ){
	        if ((hautnb==1 && supinf==-1) || (hautnb==12 && supinf==1) ) {
	          octave=octave+eval(supinf);
	          if (supinf==1) hautnb=0;
	          if (supinf==-1) hautnb=13;
	        }
	        hautnb=hautnb+supinf;
	        nmidi=nmidi+supinf;
	        compteur=compteur-1;
	    }
	    return Math.min(nmidi,160);
	  }
	  
	  var lastkey=0,idx=0;
	  for(var i = 0, inc=(this.audioCtx.sampleRate/2)/this.bufferLength; i < this.bufferLength;i++){
	    var freq = (i+0.5)*inc;
	    var key = freq2midi(freq);
	    this.keys[i] = key;
	    this.weights[key]++;
	  }
	  var holeIndex = 0;
	  for(i=0;i<128;i++){
	    if(!this.weights[i]) holeIndex = i;
	  }
	  this.holeIndex = holeIndex + 1;
	};

	Clubber.prototype.listen = function (obj) {
	  if (this.source) { this.source.disconnect(this.analyser); }
	  if ( obj instanceof AudioNode ) {
	    this.el = null;
	    this.source = obj;
	  } else {
	    this.el = obj;
	    this.source = this.audioCtx.createMediaElementSource(obj);
	  }
	  this.source.connect(this.analyser);
	};

	Clubber.prototype.band = function (config) {
	  var scope = this;
	  
	  var parseConfig = function(config) {
	    var defaults = { 
	      from:1, to:128, low:64, high:128, 
	      smooth: [0.1, 0.1, 0.1, 0.1],
	      adapt: [1.0, 1.0, 1.0, 1.0],
	      snap: 0.33, step: 1000/60,
	      template: [0, 1, 2, 3]
	    };
	    
	    if(config){
	      for (var k in defaults) {
	        if (!config[k]) config[k] = defaults[k];
	      }
	      if(typeof config.template === "string") {
	        var t = [];
	        for(var i = 0; i < config.template.length; i++)
	          t.push(parseInt(config.template[i]));
	        config.template = t;
	      }
	      var rect = {
	        from: config.from,
	        to: config.to,
	        low: this.rect ? this.rect.low : config.low,
	        high: this.rect ? this.rect.high : config.high,
	      };
	      this.rect = rect;
	      var data = new Float32Array(config.template.length);
	      if (this.data) data.set(this.data);
	      this.config = config;
	      this.data = data;
	    }
	    return this;
	  };

	  var obj = parseConfig.call({}, config);
	  
	  return function (output, offset) {    
	    
	    function fill(arr, output, offset) {
	      if (output) {
	        if (output instanceof Float32Array) {
	          output.set(arr, offset);
	        } else if(Array.isArray(output)){
	          for (var i = 0; i < 4; i++) output[offset+i] = arr[i];
	        } else if(output.fromArray){
	          output.fromArray(arr);
	        } 
	      }
	    };
	    
	    var config = obj.config, data = obj.data, rect = obj.rect;
	    if(typeof offset === "object"){
	      parseConfig.call(obj, offset);
	      offset = arguments[2];
	    }
	    
	    offset = offset || 0;
	    
	    if (obj.time > scope.time){
	      fill(data, output, offset);
	      return rect;
	    }
	    
	    var s = config.smooth, snap = config.snap, idx=0, val=0, midx=0, mval=128, vsum=0, nsum=0, xsum=0, psum=0, osum = 0, cnt=0;

	    for(var i=config.from; i < config.to;i++){
	      var V = scope.notes[i] / 2;
	      var v = Math.min(rect.high, V);
	      if (v >= rect.low) {
	        
	        // Sum musical keys and power.
	        v -= rect.low; 
	        var x = i - config.from;
	        osum += Math.floor( i  / 12) * v;
	        nsum += ( i % 12 ) * v;
	        psum += x * v;
	        vsum += v;
	        xsum += x;
	        cnt++;

	        // Strongest note.
	        if (V > val){
	          idx = i;
	          val = V;
	        } else if(v < mval) {
	          midx = i;
	          mval = v;
	        }
	      }
	    }

	    // Dont change note info if no activity was recorded
	    if(cnt) {
	      obj.midx=(midx % 12) / 12;
	      obj.idx=(idx % 12) / 12;
	      obj.avg=(nsum / vsum) / 12;
	    }
	    
	    // Exponential smoothing. When negative: snap is used when value rises and abs(value) when falling.
	    function smoothFn (v, o, f, snap){
	      v = !v ? 0 : v;
	      f = Math.min(f, snap);
	      if (f < 0) { f = v > o ? Math.abs(snap) : -f; }
	      return f * v + (1 - f) * o;
	    };
	    
	    var width = config.to - config.from, av = cnt ? vsum / cnt : 0;
	    var height = rect.high - rect.low, _height = config.high - config.low, area = width * height;
	    var ah = Math.min(config.high, config.low + av + config.adapt[2] * _height);
	    var al = Math.max(config.low, config.low + av - config.adapt[0] * _height);
	    var of = Math.floor(config.from / 12), ot = Math.floor(config.to / 12);
	    val = height ? Math.min(rect.high, Math.max(0, val - rect.low)) / height : 0;
	    
	    // fixed timestep
	    if (obj.time === undefined) obj.time = scope.time;
	    for (var t = obj.time, step = obj.config.step, tmax = scope.time + step ; t <= tmax; t += step) {
	      config.template.forEach(function (k,i) {
	        switch (k) {
	          default: 
	            data[i] = smoothFn(obj.idx, data[i], s[i], snap); break;
	          case 1: 
	            data[i] = smoothFn(obj.midx, data[i], s[i], snap); break;
	          case 2: 
	            data[i] = smoothFn(obj.avg , data[i], s[i], snap); break;
	          case 3: 
	            data[i] = smoothFn(val, data[i], s[i], snap); break;
	          case 4: 
	            data[i] = smoothFn(cnt && height ? av / height : 0, data[i], s[i], snap); break;
	          case 5: 
	            data[i] = smoothFn(vsum ? ((psum / vsum)) / width : 0 , data[i], s[i], snap); break;
	          case 6: 
	            data[i] = smoothFn(vsum ? ((osum / vsum - of)) / (ot - of) : 0, data[i], s[i], snap); break;
	          case 7: 
	            data[i] = smoothFn(area ? vsum/area:0, data[i], s[i], snap); break;
	          case 8: 
	            data[i] = smoothFn((rect.high - config.low) / _height, data[i], s[i], snap); break;
	          case 9: 
	            data[i] = smoothFn((rect.low - config.low) / _height, data[i], s[i], snap); break;
	        }
	      });
	      rect.high = smoothFn(ah, rect.high, config.adapt[3], snap);
	      rect.low = smoothFn(al, rect.low, config.adapt[1], snap);
	    }
	    
	    obj.time = t;
	    fill(data, output, offset);
	    return rect;
	  };
	};

	// You can pass the frequency data on your own using the second argument.
	Clubber.prototype.update =  function (time, data) {
	  var c = this.cache, self=this;
	  if (!data) {
	    this.analyser.getByteFrequencyData(this.data);
	    data = this.data;
	  }
	  // Calculate energy per midi note and fill holes in the lower octaves
	  for(var i = 0; i < this.notes.length; i++){
	    this.noteSums[i] = 0;
	  }
	  for(i = 0; i < this.keys.length; i++){
	    this.noteSums[this.keys[i]] += data[i];
	  }
	  
	  var lastIndex = 0, lastVal=0;
	  for(i = 0; i < this.notes.length; i++){
	    var w = this.weights[i];
	    if(!w) continue;
	    var v = this.noteSums[i] / w;
	    this.notes[i] = v;
	    if (i > this.holeIndex) continue;
	    var di = i - lastIndex;
	    var dv = v - lastVal;
	    for(var j = lastIndex ? 1 : 0 ; j < di; j++) {
	      this.notes[lastIndex + j] = lastVal + j * dv/di; 
	    }
	    lastVal = v;
	    lastIndex = i;
	  }
	  
	  this.time = time !== undefined ? parseFloat(time) : window.performance.now();
	};

	Clubber.prototype.descriptions = [
	  "Most powerful note index",
	  "Least powerfull note index",
	  "Power weighted note average",
	  "Power of the strongest note",
	  "Average power of active notes",
	  "Power weighted average midi index",
	  "Power weighted average octave index", 
	  "Ratio of spectrum window area covered",
	  "Adaptive low threshold relative to bounds", 
	  "Adaptive high threshold relative to bounds"
	];

	module.exports = window.Clubber = Clubber;

/***/ }
/******/ ]);